<app-section-page
  title="State Management with Signals"
  subtitle="Angular's answer to useState, useMemo, and useReducer â€” fine-grained reactivity without VDOM"
  icon="âš¡"
>
  <!-- Live Demo -->
  <div class="demo-card">
    <h3 class="demo-title">ğŸ® Live Signal Demo</h3>
    <p class="demo-subtitle">
      This counter runs on Angular Signals â€” no Zone.js, no full re-renders
    </p>
    <div class="counter-display" [class.even-glow]="isEven()" [class.odd-glow]="!isEven()">
      <div class="count-value" [class.even]="isEven()" [class.odd]="!isEven()">
        {{ count() }}
      </div>
      <div class="status-pill" [class.even]="isEven()" [class.odd]="!isEven()">
        <span class="status-indicator"></span>
        <span class="status-text">{{ isEven() ? 'Even' : 'Odd' }}</span>
      </div>
    </div>
    <div class="counter-buttons">
      <button class="btn btn-secondary" (click)="decrement()">âˆ’</button>
      <button class="btn btn-primary" (click)="increment()">+</button>
      <button class="btn btn-ghost" (click)="reset()">Reset</button>
    </div>
    <div class="computed-display">
      <div class="computed-item">
        <span class="computed-label">ğŸ”¢ count()</span>
        <span class="computed-value">{{ count() }}</span>
      </div>
      <div class="computed-item">
        <span class="computed-label">âœ–ï¸ doubleCount()</span>
        <span class="computed-value">{{ doubleCount() }}</span>
      </div>
      <div class="computed-item">
        <span class="computed-label">ğŸ‘‹ greeting()</span>
        <span class="computed-value greeting-val">{{ greeting() }}</span>
      </div>
    </div>
  </div>

  <!-- Concept Explanation -->
  <div class="concept-box">
    <h3 class="concept-title">ğŸ’¡ What are Angular Signals?</h3>
    <div class="concept-content">
      <p>
        Signals are <strong>reactive, synchronous primitives</strong> introduced in Angular 16.
        Unlike React's useState which triggers a full component re-render, Signals allow Angular to
        update <em>only the specific DOM nodes</em> that depend on the signal.
      </p>
      <div class="concept-grid">
        <div class="concept-item">
          <span class="concept-icon">ğŸ“¦</span>
          <div><strong>signal()</strong> â€” writable reactive value (â‰ˆ useState)</div>
        </div>
        <div class="concept-item">
          <span class="concept-icon">ğŸ§®</span>
          <div><strong>computed()</strong> â€” derived value, lazily cached (â‰ˆ useMemo)</div>
        </div>
        <div class="concept-item">
          <span class="concept-icon">ğŸ‘€</span>
          <div><strong>effect()</strong> â€” runs when signals change (â‰ˆ useEffect)</div>
        </div>
        <div class="concept-item">
          <span class="concept-icon">ğŸ”—</span>
          <div><strong>linkedSignal()</strong> â€” writable derived signal (Angular 19+)</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Comparison 1: Basic State -->
  <div class="comparison-section">
    <h3 class="comparison-title">1. Basic State â€” useState vs signal()</h3>
    <app-comparison-card
      [reactCode]="basicStateReact"
      [angularCode]="basicStateAngular"
      reactLabel="React useState"
      angularLabel="Angular signal()"
    />
    <div class="key-diff-note">
      <strong>Key difference:</strong> React rerenders the <em>entire component function</em> when
      state changes. Angular Signals update only the specific template bindings â€” more efficient
      with complex UIs.
    </div>
  </div>

  <!-- Comparison 2: useMemo vs computed -->
  <div class="comparison-section">
    <h3 class="comparison-title">2. Derived State â€” useMemo vs computed()</h3>
    <app-comparison-card
      [reactCode]="useMemoReact"
      [angularCode]="computedAngular"
      reactLabel="React useMemo"
      angularLabel="Angular computed()"
    />
    <div class="key-diff-note">
      <strong>Key difference:</strong> React <code>useMemo</code> requires manually declaring
      dependency arrays. Angular <code>computed()</code> <em>automatically tracks</em> which signals
      it reads â€” no missing dependency bugs!
    </div>
  </div>

  <!-- Comparison 3: useReducer vs signal update patterns -->
  <div class="comparison-section">
    <h3 class="comparison-title">3. Complex State â€” useReducer vs signal.update()</h3>
    <app-comparison-card
      [reactCode]="useReducerReact"
      [angularCode]="signalUpdateAngular"
      reactLabel="React useReducer"
      angularLabel="Angular signal.update()"
    />
    <div class="key-diff-note">
      <strong>Tip:</strong> Angular doesn't have a built-in reducer pattern but signal's
      <code>update(fn)</code> method covers most cases. For complex state machines, use an NgRx
      store or a service with signals.
    </div>
  </div>

  <!-- linkedSignal Bonus -->
  <div class="comparison-section">
    <h3 class="comparison-title">4. Angular-Specific: linkedSignal() â€” Angular 19+</h3>
    <app-code-block
      [code]="linkedSignalAngular"
      language="angular-ts"
      label="linkedSignal â€” writable derived signal"
    />
    <div class="key-diff-note">
      <strong>No React equivalent!</strong> <code>linkedSignal()</code> creates a writable signal
      whose default value is derived from another signal. Useful for "reset on change" patterns.
    </div>
  </div>
</app-section-page>
